<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="../../CSS/posts/posts.css" />
  <link rel="stylesheet" href="../../CSS/header/header.css" />
  <link href="https://fonts.googleapis.com/css?family=Montserrat:500,700&display=swap" rel="stylesheet" />
  <html xmlns="http://www.w3.org/1999/xhtml">

  </html>
  <title>Lan Sevcnikar - Blog</title>
</head>

<body>
  <div class="opening">
    <p>Hi, I'm</p>
    <h1>
      Lan Sevƒçnikar
    </h1>
    <p>I make computers do stuff</p>
  </div>
  <header class="header" id="myHeader">
    <p class="header__logo">Lan's blog</p>
    <div class="header__right">
      <a href="../../index.html" class="header__link"> Home</a>
      <a href="../../blog.html" class="header__link header__link--active">
        Blog</a>
      <a href="../../portfolio.html" class="header__link"> Portfolio</a>
    </div>
  </header>
  <div class="mainBody">
    <div class="post">
      <a href="../../blog.html" style="text-decoration: none; color: #3b3b3b;">Go back</a>
      <h1>
        Travelling salesperson problem
        <a href="https://en.wikipedia.org/wiki/Travelling_salesman_problem"
          style="color: #3b3b3b; font-size: 0.5em;">[wiki]</a>
      </h1>
      <p>
        I have encountered the problem many times before while attending the lectures made for IOI. So I was rather
        familiar with the problem and the optimal solution. Yet, it was discovering the plethora of solutions that are
        meant to approximate the optimal solution that made me interested in tackling and visualizing this problem.
      </p>
      <p>
        I also made a few simplifications to the problem. While all of these algorithms, I think, would work on the
        abstract version of this problem, I did simplify it by getting rid of such concepts as edges. As all of the
        nodes are actually just points in Euclidean space, it means that all points could be connected to all other
        points as well as that the shortest path from node A to node B is the edge connecting them directly. This was
        done mainly to simplify the visual part of the problem as well as I think that it changes the actual programs
        little other than adding some boring checks in the end to see if the code could work.
      </p>

      <p>
        I implemented the following solutions:
      <ol>
        <li>Random</li>
        <li>Greedy</li>
        <li>Brute force</li>
        <li>Dynamic</li>
        <li>Ant colony optimization</li>
        <li>2 optimization</li>
        <li>Simulated annealing</li>
      </ol>
      as well as a way to generate worlds, involving both a <i> completely random world </i> and a <i> small world </i> system. It was in
      my interest to also implement the 3 optimization algorithms as well as the Christofides algorithm yet I decided
      against that as the former is similar to the 2 opt yet just a lot of code and the latter was to my surprise so
      difficult to find (finding the perfect matchings) that I decided to take a break from it all.
      </p>
      <h3>
        Random and greedy
      </h3>
      <p>
        Two incredibly simple algorithms. At each step of the way, the random algorithm takes a random node as the next
        node while the greedy algorithm takes the node that is the closest to it. As one could imagine, choosing them at
        random is an incredibly bad decision and results in incredibly long paths yet the greedy solution surprised me
        with just how effective it was.
        <p>
          Random: O(n) <br>
          Greedy: O(n^2)
        </p>
      </p>
      <h3>
        Brute force (naive) and dynamic programming
      </h3>
      <p>
        These two have been well known to me for a few years now as they are the "cream de la cream" of dynamic
        programming. The brute force that I implemented is incredibly bad and would actually out-preformed significantly
        by the dynamic solution even if we were to take out the memoization. We start of by generating an array of all
        possible paths we could take and then iterate through it to find the most optimal one. As expected from a
        brute force solution, the complexity is actually factorial to the number of nodes. The pre-generation of all the
        paths actually allowed me to implement the visual part much easier as each frame is representative of checking
        one of the already computed permutations.
        <p>
          Brute force: O(n!)
        </p>
      </p>
      <p>
        The dynamic solution is also incredibly simple. We notice that we can recursively solve the problem by calling
        the function with two parameters. The current node that we are on and the set of all nodes that we have visited
        thus far. We can notice that it is possible to disregard in what order we visited the previous nodes and
        therefore we can use memoization to go from an algorithm that runs in factorial time to one that runs in
        exponential.
        <p>
          Dynamic: O(2^n)
        </p>
      </p>  
      <h3>
        Ant colony optimization
      </h3>
      <p>
        This algorithm works on the assumption that ants are able to find the shortest path by passive communication through eachother and very simple, modular thinking. 
        Each ant at every points decides what node to visit next based on the pheromones on the edge and the distance to the node. 
        Pheromones slowly evaporate, so paths that are not taken are slowly forgotten while the paths that are taken are reinforced.
      </p>
      <p> 
        Although the logic itself was not too hard to implement, the real difficulty came in the fine tuning of the parameters.
        There are (at least in my code) 4 parameters you have to fiddle with, each being better suited for some problems than others.
        But if the parameters are fine tuned for the problem (that is dependant on the amount of ants, amount of nodes, size of screen, distribution of nodes...)
        this is actually a rather fun algorithm to watch and also effective at really large problems (sadly, large problems and this Javascript implementation do not align too well).
        To be honest, I find myself disappointed by this algorithm as it is not as effective as I would have hoped. 
      </p>
      <h3>
        2 opt optimizings
      </h3>
      <p>
        A very brute and simple algorithm. We take two edges and swap them if the new path is shorter. We do this for all possible combinations of edges.
        A version of this exists for 3 edges but I did not implement it as it is a lot more code but no more thinking.
        In a way, I am sad by how effective it is, it somehow manages to be so much better than the ant colony optimization and yet it is so simple.
        <p>
          2 opt: O(n^2)
        </p>
      </p>
      <h3>
        Simulated annealing
      </h3>
      <p>
        Another algorithm that takes inspiration from the real world, this time from the way crystal formation happens. An odd spin of the 2 opt, we take a random edge and swap it with another edge. If the new path is shorter, we take it; if it is longer, we take it with a probability
        proportional to the temperature (the higher the temperature, the more likely we are to take a longer path). The temperature slowly decreases over time.
        With this, we can escape local minima and find the global minimum.
      </p>
      <h3>
        Conclusion
      </h3>
      <p>
        There is a lot written on these problems already so I try to avoid talking much about it but I would personally
        checks <a href="https://www.amazon.com/Competitive-Programming-3rd-Steven-Halim/dp/B00FG8MNN8">Competitive
          programming 3</a> if you were to be interested in more detailed explanations of
        these simple algorithms.
      </p>
    
      Uwu, have fun.
      </p>
      <div id="outValue" style="display: inline-block; position: relative; width: 100%;">
        <div id="inValue" style="margin-top: 75.25%;"></div>
        <iframe src="code/index.html" style="
              position: absolute;
              top: 0;
              bottom: 0;
              left: 0;
              right: 0;
              border-radius: 1em;
            " width="100%" height="100%"></iframe>
      </div>
      <h1>
        References
      </h1>
      <ul>
        <li style="word-wrap: break-word;">None</li>
      </ul>
    </div>
  </div>
</body>

</html>